---
layout: post
title:  "고루틴 톺아보기 (1)"
date:   2022-06-12 18:00:00 +0900
categories: tech 
---
## 고루틴은 왜 빠를까?
Go 언어의 가장 큰 장점은 개발자가 동시성을 구현하기 편하다는 점입니다. 또한 고루틴 덕분에 병렬 처리 속도가 타 언어 대비 빠릅니다. 하지만 단순히 빠르다고 알고 쓰는 것과 왜 빠른지 정확히 이해하는 것은 다릅니다. 이 글에서는 고루틴이 왜 빠른지 어렵지 않게 살펴봅니다.

## Back to OS class
먼저 스레드에 대해 잠시 복기 해봅시다. 위키피디아에서 스레드는 프로세스 내에서 *실행되는 흐름*의 단위라고 말합니다. 여기서 *실행되는 흐름*이란 무엇일까요? 프로그램의 실행은 CPU가 메모리로부터 명령어를 가져(fetch)와 해석(decode)하고 실행(excute)하는 과정의 연속입니다. 특정 프로그램에 대한 이 과정의 연속을 *실행되는 흐름*이라고 볼 수 있습니다.

*실행되는 흐름* 속에서 CPU는 레지스터에 쓰레드의 SP(Stack Pointer)와 PC(Program Counter) 등을 저장합니다. 만약 CPU가 다른 쓰레드를 실행해야 하는 상황이 오면 어떻게 할까요? 이 정보들을 잠시 메모리에 저장합니다. 그리고 다른 쓰레드의 SP, PC 등을 레지스터에 로드하여 해당 쓰레드가 저장된 시점부터의 *실행되는 흐름*을 이어갑니다. 이것이 커널 레벨에서 발생하는 컨텍스트 스위칭입니다. 이것이 수행되는 시간은 μs 단위로 알려져 있습니다.

## 고루틴 = 사용자 스레드
스레드는 두 가지 종류가 있습니다. 사용자 스레드와 커널 스레드가 그것입니다. 사용자 스레드는 커널과 무관하게 사용자 공간에서 실행됩니다. 커널은 사용자 스레드의 존재를 알지 못합니다. CPU 입장에서는 같은 쓰레드를 계속해서 실행하고 있다고 여깁니다. 실제로 이 커널 쓰레드는 여러 사용자 쓰레드에 맵핑되어 각 사용자 쓰레드의 명령어를 처리하고 있는데도 말이죠.

![image](https://user-images.githubusercontent.com/3898834/178537185-4870bfc7-1e96-4501-bf50-0577950625ac.png)

*위 그림은 출처의 글에서 가져왔습니다.*

고루틴도 마찬가지 입니다. 아래 그림과 같이 여러 고루틴이 대기 중인 큐가 하나의 커널 쓰레드에 할당되게 됩니다. 컨텍스트 스위칭이 발생한다면 커널 스레드에서 발생하는 것이 아니고 고루틴 사이에서 발생합니다. 이는 μs 단위보다 훨씬 빠른 속도로 이뤄집니다. 다른 언어들보다 속도면에서 훨씬 큰 이점을 갖게 되는 것이죠.

## 고루틴과 IO 처리
만약 IO와 같은 시스템콜로 인해 쓰레드가 블록되면 어떻게 될까요? 커널은 새로운 쓰레드를 생성해 큐에 대한 제어를 넘깁니다. 새로운 쓰레드가 이어서 큐의 다른 고루틴을 실행시킬 것입니다. 블록된 쓰레드는 IO 처리가 끝나기를 기다립니다.

![image](https://user-images.githubusercontent.com/3898834/178539265-19c789de-68d3-4f56-9700-39e67b39f63f.png)

*위 그림은 출처의 글에서 가져왔습니다.*

## 참조
https://medium.com/@genchilu/javas-thread-model-and-golang-goroutine-f1325ca2df0c
